install.packages("readr")
install.packages("readr")
install.packages("dplyr")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("DESeq2")
install.packages("WGCNA")
## Revisit Chow et al., PNAS 2020 bulk RNA seq data
# CRAN
library(readr)
library(dplyr)
library(WGCNA)
BiocManager::install("GO.db")
library(WGCNA)
BiocManager::install("impute")
library(WGCNA)
BiocManager::install("preprocessCore")
library(WGCNA)
# Bioconductor
library(DESeq2)
### counts data ---
r_count <- read_csv("Documents/GitHub/Revisit_RNAseq_2020_Chow_PNAS/Data/Chow_PNAS_rawcounts.csv")
setwd("~/Documents/bfx_proj/Revisit_RNAseq_2020_Chow_PNAS/")
### counts data ---
r_count <- read_csv("Data/Chow_PNAS_rawcounts.csv")
r_count <- r_count[!duplicated(r_count$gene), ] # remove dupilicate genes
cnt_mtx <- as.matrix(r_count[, -1]) # make numerical matrix
rownames(cnt_mtx) <- r_count$gene
### metadata ---
sp_meta <- read_csv("Data/Chow_PNAS_meta.csv")
BiocManager::install("org.Hs.eg.db")
BiocManager::install("ReactomePA")
BiocManager::install("clusterProfiler")
# clean up
rm(r_count)
setwd("~/Documents/bfx_proj/Revisit_RNAseq_2020_Chow_PNAS/")
### counts data ---
r_count <- read_csv("Data/Chow_PNAS_rawcounts.csv")
r_count <- r_count[!duplicated(r_count$gene), ] # remove dupilicate genes
cmtx <- as.matrix(r_count[, -1]) # make numerical matrix
rownames(cmtx) <- r_count$gene
### metadata ---
meta <- read_csv("Data/Chow_PNAS_meta.csv")
### gene synonym reference ---
hs <- org.Hs.eg.db
hs <- AnnotationDbi::select(hs,
keys = rownames(cmtx),
columns = c("ENTREZID"),
keytype = "SYMBOL")
hs <- hs[!duplicated(hs$SYMBOL), ]
# clean up
rm(r_count)
rm(cnt_mtx, sp_meta)
### normalize in DESeq2 ---
ds2_ <- DESeqDataSetFromMatrix(countData = cmtx, colData = meta, design = ~ 1)
ds2_ <- DESeq(ds2_) # run DESeq2
ds2_ <- t(counts(ds2_, normalized = T)) # extract normalized counts, transpose for WGCNA
### normalize in DESeq2 ---
ds2_ <- DESeqDataSetFromMatrix(countData = cmtx, colData = meta, design = ~ 1)
ds2_ <- DESeq(ds2_) # run DESeq2
cmtx_n <- t(counts(ds2_, normalized = T)) # extract normalized counts, transpose for WGCNA
### WGCNA qc for genes and samples ---
gsg_w <- goodSamplesGenes(cmtx_w)
cmtx_w <- t(cmtx_n) # transpose for WGCNA
### WGCNA qc for genes and samples ---
gsg_w <- goodSamplesGenes(cmtx_w)
if (!gsg_w$allOK){
if (sum(!gsg_w$goodGenes) > 0)
printFlush(paste("Removing genes:", paste(colnames(cmtx_w)[!gsg_w$goodGenes], collapse = ", ")));
if (sum(!gsg_w$goodSamples) > 0)
printFlush(paste("Removing samples:", paste(rownames(cmtx_w)[!gsg_w$goodSamples], collapse = ", ")));
# Remove the offending genes and samples from the data:
cmtx_w <- cmtx_w[gsg_w$goodSamples, gsg_w$goodGenes]
}
# clean up
rm(gsg_w)
# clean up
rm(ds2_, gsg_w)
# assay possible thresholds
sft_w <- pickSoftThreshold(cmtx_w, powerVector = c(c(1:10), seq(from = 12, to = 20, by = 2)))
sft_w
sft_w$powerEstimate
c(c(1:10), seq(from = 12, to = 20, by = 2))
### normalize counts in DESeq2 ---
ds2_ <- DESeqDataSetFromMatrix(countData = cmtx, colData = meta, design = ~ 1)
ds2_ <- DESeq(ds2_) # run DESeq2
cmtx_w <- t(counts(ds2_, normalized = T)) # extract normalized counts, transpose for WGCNA
### WGCNA qc for genes and samples ---
gsg_w <- goodSamplesGenes(cmtx_w)
if (!gsg_w$allOK){
if (sum(!gsg_w$goodGenes) > 0)
printFlush(paste("Removing genes:", paste(colnames(cmtx_w)[!gsg_w$goodGenes], collapse = ", ")));
if (sum(!gsg_w$goodSamples) > 0)
printFlush(paste("Removing samples:", paste(rownames(cmtx_w)[!gsg_w$goodSamples], collapse = ", ")));
# Remove the offending genes and samples from the data:
cmtx_w <- cmtx_w[gsg_w$goodSamples, gsg_w$goodGenes]
}
# clean up
rm(ds2_, gsg_w)
# assay possible thresholds
sft_w <- pickSoftThreshold(cmtx_w, powerVector = c(c(1:10), seq(from = 12, to = 20, by = 2)))
### Filter top variant genes for speed ###
cmtx_w <- cmtx_w[, order(colVars(as.matrix(cmtx_w)), decreasing = T)[1:5000]]
# assay possible thresholds
sft_w <- pickSoftThreshold(cmtx_w, powerVector = c(c(1:10), seq(from = 12, to = 20, by = 2)))
sft_w$powerEstimate
### calculate gene similarity ---
adj_w <- adjacency(cmtx_w, power = sft_w$powerEstimate) # calculate adjacency matrix; how connected each gene is to other genes
tom_w <- TOMsimilarity(adj_w) # calculate topological overlap
geneTree_w <- hclust(as.dist(1 - tom_w), method = "average") # calculate gene tree by dissimilarity
### assign genes to gene module; produces vector of module assignments for each gene ---
mods_w <- cutreeDynamic(geneTree_w, # clustering
distM = 1 - tom_w, # distance matrix
deepSplit = 2,
pamRespectsDendro = F,
minClusterSize = 30) # minimum cluster size is large ~30
### estimate module similarity ---
MEs_w <- moduleEigengenes(cmtx_w, colors = labels2colors(mods_w)) # calculate eigengenes (samples) with un-merged ME color assignment
MEs_ext_w <- MEs_w$eigengenes # extract eigengenes; eigengenes are samples, therefore looking for similarity across all samples
METree_w <- hclust(as.dist(1-cor(MEs_ext_w)), # dissimilarity matrix: col is gene modules, row is samples
method = "average") # construct dendrogram
plot(METree_w, sub = "", xlab = "", cex = 0.6)
abline(h = 0.4, col = "red") # dissimilarity threshold e.g. (0.25 is similarity of 0.75)
abline(h = 0.25, col = "red") # dissimilarity threshold e.g. (0.25 is similarity of 0.75)
abline(h = 0.2, col = "red") # dissimilarity threshold e.g. (0.25 is similarity of 0.75)
abline(h = 0.1, col = "red") # dissimilarity threshold e.g. (0.25 is similarity of 0.75)
### merge similar modules ---
mods_merg_w <- mergeCloseModules(cmtx_w, labels2colors(mods_w), cutHeight = 0.1) # merge similar modules
plotDendroAndColors(geneTree_w, cbind(labels2colors(mods_w), mods_merg_w$colors),
c("Initial modules", "Merged modules"),
dendroLabels = FALSE, hang = 0.03,
cex.colorLabels = 0.6,
addGuide = TRUE, guideHang = 0.05)
names(meta)
### shorten and dummify metadata
meta_w <- meta[, c("age", "sex", "path_T_stage", "treatment")]
meta_w <- data.frame(meta_w[, "age"],
dummify(meta_w$sex),
dummify(meta_w$treatment))
install.packages("spatstat")
library(spatstat)
meta_w <- data.frame(meta_w[, "age"],
dummify(meta_w$sex),
dummify(meta_w$treatment))
names(meta_w)
### correlate final modules to traits ---
MEs_w <- moduleEigengenes(cmtx_w, mods_merg_w$colors)$eigengenes # re-calculate eigengenes with merged ME colors
MEs_w <- orderMEs(MEs_w) # cluster MEs by similarity; put grey (unassigned) at end
moduleTraitCor_w <- cor(MEs_w, meta_short_w, use = "p") # correlation of sample eigenvalue vs sample meta value; pairwiase complete observations
moduleTraitCor_w <- cor(MEs_w, meta_w, use = "p") # correlation of sample eigenvalue vs sample meta value; pairwiase complete observations
moduleTraitPvalue_w <- corPvalueStudent(moduleTraitCor_w, nrow(cmtx_w)) # calculate P value of correlations
moduleTraitFDR_w <- matrix(p.adjust(moduleTraitPvalue_w, method = "BH"),
nrow = nrow(moduleTraitPvalue_w),
ncol = ncol(moduleTraitPvalue_w)) # adjust by FDR
head(moduleTraitPvalue_w)
head(moduleTraitCor_w)
Heatmap(moduleTraitCor_w)
BiocManager::install("ComplexHeatmap")
library(Heatmap)
BiocManager::install("ComplexHeatmap")
library(ComplexHeatmap)
Heatmap(moduleTraitCor_w)
### plot module eigenvalue vs trait
set.seed(415); Heatmap(moduleTraitCor_w)
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"))
Heatmap(moduleTraitCor_w,
name = "Correlation")
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/2 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
install.packages("circlize")
library(circlize)
col_fun <- circlize::colorRamp2(c(-1, 0, 1), c("green", "white", "red"))
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/2 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
col_fun()
col_fun
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = 2, height = 2,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/2 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/2 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/10 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/1 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/1 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/4 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/4 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
})
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
},
cluster_columns = F)
Heatmap(moduleTraitCor_w,
name = "Correlation",
rect_gp = gpar(type = "none"),
cell_fun = function(j, i, x, y, width, height, fill) {
grid.rect(x = x, y = y, width = width, height = height,
gp = gpar(col = "grey", fill = NA))
grid.circle(x = x, y = y, r = abs(-log10(moduleTraitFDR_w)[i, j])/5 * min(unit.c(width, height)),
gp = gpar(fill = col_fun(moduleTraitCor_w[i, j]), col = NA))
},
cluster_columns = F,
show_heatmap_legend = F)
?unit.c
